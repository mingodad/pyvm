__autosem__

from mailnews.mime import parse_headers, rfc2047, NameFromAddr
from time import rfc1123, monday
from re import re, IGNORECASE
import os
rfc2047ToAscii = rfc2047.decode

class messages
{
	method base_init ()
		# subclass msg so that the "newsgroup" is a -common- class variable
		class $MSG ($Type == "news" ? news_msg : $Type == "mail" ? email_msg : 0)
			N = self
	method FILE (f)
		return $DIR + f
	method open (f, *args)
		return open ($DIR + f, *args)
	method access (f, *args)
		return os.access ($DIR + f, *args)
	method F (n)
		return "%x.msg" %n

	method read_index_file ()
		return read_index_file ($INDEX)

	method load_index (fast=False)
	{
		# load index file and create threading.
		R = {}
		D = {}
		P = {}
		L = []
		T = []
		TID = []

		gather = R.gather
		def addref (post, reply)
		{
			gather (post, reply)
			P [reply] = post
		}

		for (n, auth, subj, id, date, ref in $read_index_file ()) {
			if (id in D) # shouldn't happen
				continue
			D [id] = n, auth, subj, date
			L.append (id)
			# some jokers do that
			if (ref == id) ref = ""
			if (ref and ref in D) 
				addref (ref, id)
			else if (!subj.sw ('Re: ')) {
				T.append (id)
				TID.append (subj)
			} else {
				try addref (T [TID.index (subj [4:])], id)
				except {
					T.append (id)
					TID.append (subj [4:])
				}
			}
		}

		# Factor out message dates into an array()
		first_n = D [L [0]][0] ?? 0
		last_n = D [L [-1]][0] ?? 0
		Dates = array ("i", 1 + last_n - first_n)
		for (id in L) {
			n, auth, subj, date = D [id]
			Dates [n - first_n] = date
			D [id] = n, auth, subj
		}
		$first_n = first_n
		$Dates = Dates

		$Posts = D
		$ByNum = L
		$Replies = R
		$Parents = P
		$Threads = T
		$NOPS = len (T)
		$NMSG = len (L)
		$LastID = $Posts [$ByNum [-1]][0] ?? 0
	}

	method load_tags ()
	{
		from marshal import load
		try $SEEN = set (load ($open ("SEEN")))
		except $SEEN = set ()
	}

	method save_tags ()
	{
		from marshal import dump
		dump (tuple ($SEEN), $open ("SEEN", "w"))
	}

	#
	method data_ready (n)
		return $access ($F (n))

	# Helpers that return msg() objects

	method ith (i)
		return $MSG ($ByNum [i])

	method pth (i)
		return $MSG ($Threads [i])

	method All ()
		for (i in $ByNum)
			yield $MSG (i)

	method Last (n)
		for (i in $ByNum [-n:])
			yield $MSG (i)

	method AllOP ()
		for (i in $Threads)
			yield $MSG (i)

	method AllAfter (tm)
	{
		# yield all messages posted after date "tm".
		# The "time" of a message is generated by the sender and
		# for that it may be wrong. 
		# In order to fix that we study some more messages in the
		# queue, assuming that _most_ senders have their clocks
		# configured properly.

		p = $Posts
		Dates = $Dates
		first_n = $first_n
		it = reversed ($ByNum)
		for (m in it) {
			t = Dates [p [m][0] - first_n]
			if (t >= tm) yield $MSG (m)
			else {
				# look next 8 messages
				M = [m]
				b = n = 0
				for (m in it) {
					M.append (m)
					t = Dates [p [m][0] - first_n]
					if (t >= tm) b += 1
					if (n > 8) break
					n += 1
				}
				# if more than 3 messages from the next
				# are after "tm", then accept them all
				if (b > 3) {
					for (m in M)
						yield $MSG (m)
				} else break
			}
		}
	}
}

##
## convenient message class
## ideal for programmatically scanning newsgroups
##

NOW = now ()

class msg
{
	__slots__ = ("id",)
	method __init__ ($id);

	# message fields from index
	method date    () return $N.Dates [$N.Posts [$id][0] - $N.first_n]
	method dateh   () return max ((NOW - $date ()) / 3600, 0)
	method subject () return $N.Posts [$id][2]
	method author  () return $N.Posts [$id][1]
	method n       () return $N.Posts [$id][0]
	method __eq__ (n) return $id == n.id

	# rightly encoded
	method Subject    () return rfc2047ToAscii ($subject ())
	method AuthorName () return NameFromAddr ($author ())
	method Author     () return rfc2047ToAscii ($author ())
	method Date       () return rfc1123 ($date ())
	method ShortDate  () return monday ($date ())

	# messages: parent, OP, replies
	method parent () try return $N.MSG ($N.Parents [$id])
	method op ()
	{
		op = self
		while (1)
			if (!(p = op.parent ())) return op
			else op = p
	}
	method replies ()
		if ($id in $N.Replies)
			for (r in $N.Replies [$id])
				yield $N.MSG (r)
	method nreplies ()
		return len ($N.Replies [$id]) ?? 0
	method depth ()
	{
		op = self
		d = 0
		while (1)
			if (!(p = op.parent ())) return d
			else {
				op = p
				d += 1
			}
	}
	# all replies & self
	method allreplies ()
	{
		a = []
		b = [$id]
		while (b) {
			m = b.pop (0)
			a.append (m)
			if (m in $N.Replies)
				b = $N.Replies [m] + b
		}
		return [$N.MSG (m) for (m in a)]
	}
	method nallreplies ()
		return len ($allreplies ()) - 1
	method nallseenreplies ()
		return len ([None for (x in $allreplies ()) if (x.is_seen ())])
	method nauthors ()
		return len (set ([r.author () for (r in $allreplies ())]))
	method lrd ()
		return max ([i.date () for (i in $allreplies ())])
	method lrdh ()
		return min ([i.dateh () for (i in $allreplies ())])
	# string identifying depth/nreply
	method target ()
		try return "%i/%i" %($depth (), [x for (x in $parent ().replies ())].index (self)+1)
		except return "0/1"
	# parents
	method parents ()
	{
		p = self
		while (p = p.parent ())
			yield p
	}
	# treeview
	method is_last_reply ()
	{
		if (!(p = $parent ())) return True
		return $N.Replies [p.id][-1] == $id
	}
	method is_reply_to (m)
		return $parent () and m == $parent ()
	# active thread
	method has_unseen_replies ()
		for (m in $allreplies () [1:])
			if (!m.is_seen ()) return True
	#
#	method __cmp__ (m)
#		return cmp ($id, m.id)
#	method __hash__ ()
#		return hash ($id)

	# messages: nextOP, prevOP.  message must be OP.
	method nextop ()
		try return $N.MSG ($N.Threads [$N.Threads.index ($id) + 1])
	method prevop ()
		try return $N.MSG ($N.Threads [$N.Threads.index ($id) - 1])
	# messages: next, prev by message number (can improve O(n) speed with $n)
	method next ()
		try return $N.MSG ($N.ByNum [$N.ByNum.index ($id) + 1])
	method prev ()
		try if (i = $N.ByNum.index ($id)) return $N.MSG ($N.ByNum [i - 1])
	# message body
	method data_ready () return $N.have_data ($n ())
	method data ()       return $N.get_article ($n ())
	method store ()      if (d = $data ()) $N.open ($N.F ($n ()), "w").write (d)

	# remove from index file
	method remove ();
	method __str__ () return "Msg %i: \"%s\" -- %s" %($n (), $subject (), $author ())
}

class email_msg (*msg)
{
	Type = "mail"
	method is_seen    () return $id in $N.SEEN
	method mark_seen  () $N.SEEN.add ($id)
	method delete	  () $N.DELd.add ($id)
	method undelete	  () del $N.DELd [$id]
	method isdeld	  () return $id in $N.DELd
}

class news_msg (*msg)
{
	Type = "news"
	method is_seen    () return $n () in $N.SEEN
	method mark_seen  () $N.SEEN.add ($n ())
}

RERe = re (r"(?:\s*re\s*:+\s*)+", IGNORECASE)

# XXX: in the case of email it might make sense to add the CC: and TO:
# headers in the index file so that we know if we are pinged in a mailing
# list. The alternative is mailbox views where a mail box is separated to
# all the messages where we are included in the recipients and not.

# `fast`: read only last 5000 entries

def read_index_file (f, fast=False)
{
	if (!havefile (f))
		return

	Da = {}
	Ia = Da.setdefault
	Ds = {}
	Is = Ds.setdefault
	Di = {}
	Ii = Di.setdefault

	if (fast) {
		l = readfile (f).split ("\n")
		l.pop ()
		l = l [-5000:]
	} else {
		def l ()
			for (i in open (f))
				yield i [:-1]
		l = l()
	}
	for (k in l) {
		no, id, subj, auth, date, ref = k.split ("\t")

		# fix whitespace damaged subject.
		if ("  " in subj)
			do subj = subj.replace ("  ", " ")
			while ("  " in subj)

		if (ref) ref = Ii (ref)
#		if (subj [0] in ' r' and !subj.sw ("Re: "))
			if (r = RERe (subj))
				subj = "Re: " + subj [len (r [0]):]
		yield int (no, 16), Ia (auth), Is (subj), Ii (id), int (date, 16), ref
	}
}
