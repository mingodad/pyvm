Framebuffer formats
===================

The basic format is 24-bit RGB.  This means that the first byte of the
framebuffer memory is color RED of pixel at (0,0).

This is the "raw" RGB that is, for example, generated by libjpeg when
an image is decompressed.

All image decompression routines (pyvm's jpeg decoder, GIF, PNG, PPM)
produce raw images of that format.

This format is the parameter "bpp=3" of the framebuffer class.


Other formats
=============

The framebuffer may use some different format when it maps on the graphics
backend.  There is a big confusion with RGB/BGR hardware formats for
little/big endian systems and gfx wrappers.  What we do is what works on
a simple linux framebuffer and SDL-on-X11 with specific depths requested
on the same machine.


bpp=2, 16-bit:

	This is the format BGR16 which is common on PCs.
	For the color 0xFF0000, in memory we have the bytes: 0, 248
	For the color 0x0000FF, in memory we have the bytes: 31, 0

bpp=4, 32-bit:

	This is the format BGRA also used by PC backends.
	For a color 0xFF7711, in memory we have the bytes: 0x11, 0x77, 0xFF, 0x00

bpp=1, 8-bit:
	Special case. 8bpp does not make any sense as a true graphics framebuffer
	device. The framebuffers of bpp=1 are used for grayscale images. For the
	"color" value passed to "fill_rect", "put_pixel", only the low 8 bits are
	used.
	A framebuffer of bpp=1 can be converted to an RGB framebuffer.
	The oposite is not possible: trying to convert any bpp(2,3,4) to a
	greyscale framebuffer will raise an error.


X11
---

Note that in X11 the screen format of 24bpp does not really exist.
The ShmCreateImage uses ZPixmaps which are BGRA in this case; so it is not really
easy to test 24BPP on linux.  When SDL runs on X11 it, too, uses 32BPP in the
case the X server is at 24bpp.  I think the same happens for VNC: the 24bpp
depth does not exist as an option.

In order to see what happens in 24bpp backend you can hack the file Clib/sdl.c
and force it to use a 24bpp display despite of what the hardware wants.  In this
case in x86 pyvm's colors are indeed reversed.

We need some feedback to decide if the reversed BGR case is worth implementing.


Missing
-------

Many cases are obviously missing.  Almost all of them are for big endian
systems (for the cases of 16 and 32 bits).

The "reversed" case is the simple RGB-24 one which according to the default
format for the pyvm framebuffers, corresponds to a big endian system.

It is assumed that 24bpp displays are uncommon.  People either go for
16bpp or 32bpp.


Who cares
---------

Generally, an RGB image may be constructed either with:

	- Drawing primitives on the framebuffer. Values are in 0xRRGGBB
	  form for all formats so this works.
	- Loading images.  Image conversions done automatically upon blit.
	- Rendering text.  support for 16, 24 and 32 bpp.
	  the method `font.render_to (fb, x, y, text, fg_color)` takes the
	  fg_color parameter in 0xRRGGBB form and knowns automatically
	  from the parameter fb.bpp which renderer should be used.
	  There are some other methods in the "Font" object which should be
	  eventually removed and deprecated.

So, generally, you don't have to care about these formats.
An exception is C code which tries to use the framebuffer directly
In this case, the formats must get a public API.


Images with alpha
-----------------

Usually, we have the "main display area" framebuffer and "images" which
are blitted onto this framebuffer.  The main display area can't have alpha
bits.  The images of course can.  The storage of such information, is
different from most other implementations; the alpha table is a separate
WxHx1 image.  This means that the RGB data can be converted to 16bpp once
for using less memory. The `alphatab` member of `image` instances
should be a tuple where the first argument is the WxHx1 table with
value 255 for full transparency. The second item of the tuple is a boolean
specifying whether the alphatab has only 0/255 values (full or no transparency)
or whether real blending is needed. If unsure, set to real blending.

Resizing images with alphatab is not implemented.

Special-casing framebuffers with bpp=32 to store the alphatable in
the 4th byte of the RGB buffer, may be worth it.
